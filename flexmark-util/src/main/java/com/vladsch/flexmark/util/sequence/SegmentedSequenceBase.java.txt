package com.vladsch.flexmark.util.sequence;

import com.vladsch.flexmark.util.SegmentedSequenceStats;
import com.vladsch.flexmark.util.sequence.edit.BasedSegmentBuilder;
import com.vladsch.flexmark.util.sequence.edit.BasedSequenceBuilder;
import com.vladsch.flexmark.util.sequence.edit.IBasedSegmentBuilder;
import org.jetbrains.annotations.NotNull;

/**
 * A BasedSequence which consists of segments of other BasedSequences
 */
public abstract class SegmentedSequenceBase extends SegmentedSequence {
    // this is the only variable that changes for a subsequence of a segmented sequence base
    private final int baseStartOffset;    // offset to apply to this sequence's index to get index to be used for the rest of the structures

    // NOTE: the type int, short, byte depend on how many segments are in the base segmented sequence. If < 256 then byte, < 65536 then short, 3-byte indices are not implemented because most segmented sequences are <4096
    private final int[] baseSegments;     // list of segment indices for each character in the base segmented sequence, length is the length of base segmented sequence, segment index 0 is reserved for all non-base segments

    // NOTE: there are two types of base segments
    //  - type 0: only has startOffset/endOffset for characters in this segment from the original based sequence and these are also the start/end base offsets for the segment. ie. pure based subSequence
    //  - type 1: has startOffset/endOffset for the characters in this segment from the original based sequence and startOffset/endOffset for the segment. ie. some characters were deleted
    private final byte[] baseSegmentData;  // information for each BASE segment such as start index in the base segmented sequence, startOffset/endOffset for the segment and startOffset/endOffset in baseSequence

    // NOTE: each non-base char segment contains startOffset/endOffset for the segment in the basedSequence to allow reconstructing any anchors that surrounded the non-base chars during segment building
    //  there could be many types of non-base char segments:
    //  - type 0: space segments only provide length of segment, all characters are spaces
    //  - type 1: repeated char segments only provide the char and length of segment
    //  - type 2: first256 char segments have start/end offset in byte[] first256Chars array
    //  - type 3: finally the most generic have start/end offset in char[] nonBaseChars array

    private final int nonBaseIndexOffset;   // index of first non-base character in this sequence, convert index to base segmented sequence index then subtract this to get index of first non-base segment
    private final int[] nonBaseSegments;    // list of segment indices for each non-base char in the sequence, length is the length of all non-base characters of this sequence
    private final int[] nonBaseSegmentData; // information for each non-base segment such as start index in base segment sequence, startOffset/endOffset for the segment anchors and startOffset/endOffset in non-base chars

    private final byte[] nonBaseFirst256Chars;  // all non-base chars < 256 for this sequence
    private final char[] nonBaseChars;      // all non-base chars for this sequence

    private SegmentedSequenceBase(BasedSequence baseSeq, int startOffset, int endOffset, int length, boolean nonBaseChars, int[] baseSegments, int baseStartOffset) {
        super(baseSeq, startOffset, endOffset, length, nonBaseChars);
        this.baseSegments = baseSegments;
        this.baseStartOffset = baseStartOffset;
    }

    @Override
    public int getIndexOffset(int index) {
        if (index < 0 || index > length) {
            throw new StringIndexOutOfBoundsException("String index: " + index + " out of range: 0, " + length());
        }

        if (index == length && index == 0) {
            throw new StringIndexOutOfBoundsException("String index: " + index + " out of range: 0, " + length());
        }

        int segmentIndex = baseSegments[baseStartOffset + index];

        int offset = baseOffsets[baseStartOffset + index];
        return offset < 0 ? -1 : offset;
    }

    @Override
    public boolean addSegments(@NotNull IBasedSegmentBuilder<?> builder) {
        // FIX: clean up and optimize the structure. it is error prone and inefficient
        return BasedUtils.generateSegments(builder, this);
    }

    @Override
    public char charAt(int index) {
        if (index < 0 || index >= length) {
            throw new StringIndexOutOfBoundsException("String index: " + index + " out of range: 0, " + length());
        }

        int offset = baseOffsets[baseStartOffset + index];

        if (offset < 0) {
            /* HACK: allows having characters which are not from original base sequence
                 but with the only penalty for charAt access being an extra indirection,
                 which is a small price to pay for having the flexibility of adding out of
                 context text to the based sequence.
             */
            return (char) (-offset - 1);
        }
        return baseSeq.charAt(offset);
    }

    @NotNull
    @Override
    public BasedSequence subSequence(int startIndex, int endIndex) {
        if (startIndex < 0 || startIndex > length) {
            throw new StringIndexOutOfBoundsException("String index out of range: " + startIndex);
        }

        if (endIndex < 0 || endIndex > length) {
            throw new StringIndexOutOfBoundsException("String index out of range: " + endIndex);
        }

        if (startIndex == 0 && endIndex == length) {
            return this;
        } else {
            return subSequence(baseSeq, baseOffsets, baseStartOffset + startIndex, nonBaseChars, endIndex - startIndex);
        }
    }

    /**
     * Base Constructor
     *
     * @param builder builder for which to construct segmented sequence
     */
    static SegmentedSequenceBase create(IBasedSegmentBuilder<?> builder) {
        BasedSequence baseSeq = builder.getBaseSequence();
        int length = builder.length();
        int baseStartOffset = 0;
        int[] baseOffsets = new int[length + 1];

        int index = 0;
        for (Object part : builder) {
            if (part instanceof Range) {
                int iMax = ((Range) part).getEnd();
                for (int i = ((Range) part).getStart(); i < iMax; i++) {
                    baseOffsets[index++] = i;
                }
            } else if (part instanceof CharSequence) {
                CharSequence sequence = (CharSequence) part;
                int iMax = sequence.length();
                for (int i = 0; i < iMax; i++) {
                    baseOffsets[index++] = -sequence.charAt(i) - 1;
                }
            } else if (part != null) {
                throw new IllegalStateException("Invalid part type " + part.getClass());
            }
        }

        int end = baseOffsets[length - 1];
        baseOffsets[length] = end < 0 ? end - 1 : end + 1;

        int startOffset = builder.getStartOffset();
        int endOffset = builder.getEndOffset();
        boolean nonBaseChars = builder.getTextLength() > 0;

        if (baseSeq.isOption(O_COLLECT_SEGMENTED_STATS)) {
            SegmentedSequenceStats stats = baseSeq.getOption(SEGMENTED_STATS);
            if (stats != null) {
                stats.addStats(builder.size(), builder.getTextLength(), builder.getTextSegments(), length, startOffset, endOffset);
            }
        }

        return new SegmentedSequenceBase(
                baseSeq,
                startOffset,
                endOffset,
                length,
                nonBaseChars,
                baseOffsets,
                baseStartOffset
        );
    }

    private SegmentedSequenceBase subSequence(final BasedSequence baseSeq, final int[] baseOffsets, final int baseStartOffset, final boolean nonBaseChars, final int length) {
        int iMax = baseOffsets.length - 1;
        assert baseStartOffset + length <= iMax : "Sub-sequence offsets list length < baseStartOffset + sub-sequence length";

        int startOffset = 0;
        int endOffset = 0;

        if (!nonBaseChars) {
            if (baseStartOffset < iMax) {
                // start is the offset at our start, even when length = 0
                startOffset = baseOffsets[baseStartOffset];
            } else {
                startOffset = baseSeq.getEndOffset();
            }

            if (length == 0) {
                endOffset = startOffset;
            } else {
                endOffset = baseOffsets[baseStartOffset + length - 1] + 1;
                assert startOffset <= endOffset;
            }
        } else {
            // start is the first real start in this sequence or after it in the parent
            boolean finished = false;

            for (int iS = baseStartOffset; iS < iMax; iS++) {
                if (baseOffsets[iS] < 0) continue;
                startOffset = baseOffsets[iS];

                if (length != 0) {
                    // end is the last real offset + 1 in this sequence up to the start index where startOffset was found
                    for (int iE = baseStartOffset + length; iE-- > iS; ) {
                        if (baseOffsets[iE] < 0) continue;

                        endOffset = baseOffsets[iE] + 1;
                        assert startOffset <= endOffset;

                        finished = true;
                        break;
                    }
                }

                if (!finished) {
                    endOffset = startOffset;
                }

                finished = true;
                break;
            }

            if (!finished) {
                // if no real start after then it is the base's end since we had no real start after, these chars and after are all out of base chars
                startOffset = baseSeq.getEndOffset();
                endOffset = startOffset;
            }
        }

        return new SegmentedSequenceBase(
                baseSeq,
                startOffset,
                endOffset,
                length,
                nonBaseChars,
                baseOffsets,
                baseStartOffset
        );
    }

    /**
     * removed empty and return BasedSequence.NULL when no segments which is the logical result however,
     * this will mean empty node text in FencedCodeBlock will now return NULL sequence instead of an empty
     * sequence from the document.
     * <p>
     * If you need the location where content would have been use the FencedCodeBlock.getOpeningMarker().getEndOffset() + 1
     *
     * @param basedSequence base sequence for the segments
     * @param segments      list of based sequences to put into a based sequence
     * @return based sequence of segments. Result is a sequence which looks like
     *         all the segments were concatenated, while still maintaining
     *         the original offset for each character when using {@link #getIndexOffset(int)}(int index)
     * @deprecated use {@link BasedSequence#getBuilder()} and then {@link BasedSequenceBuilder#addAll(Iterable)} or if you know which are based segments vs. out of base Strings then use {@link BasedSegmentBuilder} to construct segments directly.
     */
    @Deprecated
    public static BasedSequence of(BasedSequence basedSequence, @NotNull Iterable<? extends BasedSequence> segments) {
        return create(basedSequence, segments);
    }

    @Deprecated
    public static BasedSequence of(BasedSequence... segments) {
        return create(segments);
    }
}
