[Binary search tree]: https://en.wikipedia.org/wiki/Binary_search_tree "Binary search tree - Wikipedia"
[Interval tree]: https://en.wikipedia.org/wiki/Interval_tree "Interval tree - Wikipedia"
[Segment tree - Wikipedia]: https://en.wikipedia.org/wiki/Segment_tree "Segment tree - Wikipedia"

# Segmented Sequence Optimization

Need optimization for segmented sequences which does not store index for every character but at
the same does not impact random access to characters via `charAt(n)` where n is offset from
start of sequence except by a constant factor independent of number of segments. Search $`O(log
\ n)`$ where *n* is number of segments can be made to appear to have constant time for
sequential and intra-segment random access by using per-thread caching of the current segment
index and segment data with additional checking of next/previous segment hits when the current
segment does not match, before resorting to the binary search for a given index.

Some known approaches are an [Interval tree] for overlapping multiple intervals,
[Segment tree - Wikipedia] or [Binary search tree]. All have $`O(log \ n)`$ query time.

Additionally, each `BasedSequence` needs to provide its segment information efficiently to allow
construction of a new segmented sequence consisting of subsequences of the base segmented
sequence. Being able to extract segment information using the offset and length of the
subsequence from parent structure is highly desired.

The tree structure must be immutable like the sequences it represents so beyond cost the of
creation and querying there is no concern for insert/delete/copy operation efficiency.

### Segment Binary Tree

With query time of $`O(log \ n)`$ where *n* is number of segments in the sequence not requiring
storing any information per character, a binary tree of aggregated length of ordered segments in
the sequence is ideal for segmented sequences.

An array of aggregated lengths `len[]` provides the binary tree structure. The middle entry is
the root node for the search with an initial step of $`2 ^ N > L/2`$ where L is length of
sequence.

Advantage for storage is significant especially for long sequences with few segments.

Query penalty for sequential access can be mitigated by per thread caching of last used segment
and segment index.

If a char index is within cached segment then the segment can be re-used. If it is less than the
first aggregated length then first segment can be used, if it is greater than the last
aggregated length then last segment can be used. The latter checks will eliminate a search
penalty for access starting at 0 or at length-1.

Additional checking of next/previous segments to cached segment index will eliminate the search
penalty for random access within a segment or next/previous segment, which in most use cases
should result in no binary search penalty for sequential access since string processing
operations are sequential around a given position.

Because all segments are already ordered, the aggregated length array can be generated by a
single iteration of the segments, which is already done to build the segmented sequence.
Additional variable to aggregate lengths creates no overhead either. Therefore building of the
binary tree is effectively free.

Subsequences can use the parent binary tree or a sub-section of it by defining an offset and
length of their portion of it, eliminating the overhead of searching extra segments and copying
of data. Effectively no penalty to subsequences for re-use of parent search structure.

The total storage overhead then becomes `(4 bytes * 2 + per segment overhead) * number of
segments`. 4 bytes per integer, one being the aggregated length and the other an offset of the
segment in the serialized segment byte array.

Out of base characters have additional overhead for character storage and all have access
penalty for de-serializing the segment data.

However, deserialization is only performed once the segment is positively identified. Even when
trying to determine if previous or next segment contains an index, **binary tree search data is
used** not the serialized segment data.

```
int pos = initialPos;                       // middle segment index within range
int step = initialStep;                     // step size for top level node
int[] aggr = aggregatedLengths;             // parent aggregated segment lengths array
int aggrOffset = 0;                         // offset of subsequence into parent aggregated lengths
int aggrLength = aggregatedLengths.length;  // length of subsequence's portion of parent aggregated lengths

while(step > 0) {
   if (pos < aggrOffset) pos += step;
   else if (pos >= aggrLength) pos -= step;
   else if (i < aggr[pos]) pos -= step;
   else pos += step;
   step >>= 1;
}

Seg seg = segments[pos];
// cache pos and seg, seg provides the start for the segment and pos can 
// be used to determine whether next/prev segments contain an index if it is not in the current segment 
```

### Segments for Segmented Sequences

Segments are stored in a byte array and deserialized from consecutive bytes as needed.

Each type of segment is represented by a separate class all extending `SeqSeg`. In Kotlin these
would be a sealed class. `SeqSeg` are only deserialized from a `byte[]`. Serialization is
performed by `SegmentBuilder` from a `Seg` element.

Serialized data is optimized to minimize number of bytes taken by each segment.

Numeric values can have only value starting at 0..Integer.MAX_VALUE. Negative values are not
supported.

* `BASE`: base segment representing a range of base sequence characters
  * `PURE_BASE`: base segment for whose start/end offset correspond to start/end offset of the
    character sequence.
  * `ANCHOR`: base segment representing a range of 0 span of base sequence characters
* `TEXT`: segment representing a segment of characters out of base sequence
  * `REPEATED`: segment representing a segment of a single repeated character
    * `REPEATED_SPACE`: repeated space
    * `REPEATED_ASCII`: repeated character with code < 256
  * `TEXT_ASCII`: segment where all characters code < 256, each character is stored in a byte
    array.

First byte of serialized sequence carries the information about the specifics and serialized
format of the segment:

* `SEG_TYPE`:
  * 0b0000_0000: `ANCHOR`: `startOffset`
  * 0b0010_0000: `BASE`: `startOffset`, `length`
  * 0b0100_0000: `TEXT`: `length`: `char[]`
  * 0b0110_0000: `REPEATED_TEXT`: `char`, `length`
  * 0b1000_0000: `TEXT_ASCII`: `length`, `byte[]`
  * 0b1010_0000: `REPEATED_ASCII`: `byte`, `length`
  * 0b1100_0000: `REPEATED_SPACE`: `length`
  * 0b1110_0000: `REPEATED_EOL`: `length`
* `SEG_BYTES`: encodes number of bytes used for segment's numeric values.
  * 0b0001_xxxx: no size/offset bytes. If has startOffset then offset = xxxx, length = 0, if has only length then length = xxxx, not valid if has both length and start offset
  * 0b0000_0000: 1 byte for start
  * 0b0000_0001: 2 byte for start
  * 0b0000_0010: 3 bytes for start
  * 0b0000_0011: 4 bytes for start
  * 0b0000_0000: 1 byte for length
  * 0b0000_0100: 2 bytes for length
  * 0b0000_1000: 3 bytes for length
  * 0b0000_1100: 4 bytes for length
